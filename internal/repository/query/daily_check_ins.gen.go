// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"AreYouOK/internal/model"
)

func newDailyCheckIn(db *gorm.DB, opts ...gen.DOOption) dailyCheckIn {
	_dailyCheckIn := dailyCheckIn{}

	_dailyCheckIn.dailyCheckInDo.UseDB(db, opts...)
	_dailyCheckIn.dailyCheckInDo.UseModel(&model.DailyCheckIn{})

	tableName := _dailyCheckIn.dailyCheckInDo.TableName()
	_dailyCheckIn.ALL = field.NewAsterisk(tableName)
	_dailyCheckIn.ID = field.NewInt64(tableName, "id")
	_dailyCheckIn.CreatedAt = field.NewTime(tableName, "created_at")
	_dailyCheckIn.UpdatedAt = field.NewTime(tableName, "updated_at")
	_dailyCheckIn.DeletedAt = field.NewField(tableName, "deleted_at")
	_dailyCheckIn.UserID = field.NewInt64(tableName, "user_id")
	_dailyCheckIn.CheckInDate = field.NewTime(tableName, "check_in_date")
	_dailyCheckIn.Status = field.NewString(tableName, "status")
	_dailyCheckIn.CheckInAt = field.NewTime(tableName, "check_in_at")
	_dailyCheckIn.ReminderSentAt = field.NewTime(tableName, "reminder_sent_at")
	_dailyCheckIn.AlertTriggeredAt = field.NewTime(tableName, "alert_triggered_at")

	_dailyCheckIn.fillFieldMap()

	return _dailyCheckIn
}

type dailyCheckIn struct {
	dailyCheckInDo

	ALL              field.Asterisk
	ID               field.Int64
	CreatedAt        field.Time
	UpdatedAt        field.Time
	DeletedAt        field.Field
	UserID           field.Int64
	CheckInDate      field.Time
	Status           field.String
	CheckInAt        field.Time
	ReminderSentAt   field.Time
	AlertTriggeredAt field.Time

	fieldMap map[string]field.Expr
}

func (d dailyCheckIn) Table(newTableName string) *dailyCheckIn {
	d.dailyCheckInDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dailyCheckIn) As(alias string) *dailyCheckIn {
	d.dailyCheckInDo.DO = *(d.dailyCheckInDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dailyCheckIn) updateTableName(table string) *dailyCheckIn {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")
	d.UserID = field.NewInt64(table, "user_id")
	d.CheckInDate = field.NewTime(table, "check_in_date")
	d.Status = field.NewString(table, "status")
	d.CheckInAt = field.NewTime(table, "check_in_at")
	d.ReminderSentAt = field.NewTime(table, "reminder_sent_at")
	d.AlertTriggeredAt = field.NewTime(table, "alert_triggered_at")

	d.fillFieldMap()

	return d
}

func (d *dailyCheckIn) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dailyCheckIn) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 10)
	d.fieldMap["id"] = d.ID
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt
	d.fieldMap["user_id"] = d.UserID
	d.fieldMap["check_in_date"] = d.CheckInDate
	d.fieldMap["status"] = d.Status
	d.fieldMap["check_in_at"] = d.CheckInAt
	d.fieldMap["reminder_sent_at"] = d.ReminderSentAt
	d.fieldMap["alert_triggered_at"] = d.AlertTriggeredAt
}

func (d dailyCheckIn) clone(db *gorm.DB) dailyCheckIn {
	d.dailyCheckInDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dailyCheckIn) replaceDB(db *gorm.DB) dailyCheckIn {
	d.dailyCheckInDo.ReplaceDB(db)
	return d
}

type dailyCheckInDo struct{ gen.DO }

type IDailyCheckInDo interface {
	gen.SubQuery
	Debug() IDailyCheckInDo
	WithContext(ctx context.Context) IDailyCheckInDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDailyCheckInDo
	WriteDB() IDailyCheckInDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDailyCheckInDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDailyCheckInDo
	Not(conds ...gen.Condition) IDailyCheckInDo
	Or(conds ...gen.Condition) IDailyCheckInDo
	Select(conds ...field.Expr) IDailyCheckInDo
	Where(conds ...gen.Condition) IDailyCheckInDo
	Order(conds ...field.Expr) IDailyCheckInDo
	Distinct(cols ...field.Expr) IDailyCheckInDo
	Omit(cols ...field.Expr) IDailyCheckInDo
	Join(table schema.Tabler, on ...field.Expr) IDailyCheckInDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDailyCheckInDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDailyCheckInDo
	Group(cols ...field.Expr) IDailyCheckInDo
	Having(conds ...gen.Condition) IDailyCheckInDo
	Limit(limit int) IDailyCheckInDo
	Offset(offset int) IDailyCheckInDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDailyCheckInDo
	Unscoped() IDailyCheckInDo
	Create(values ...*model.DailyCheckIn) error
	CreateInBatches(values []*model.DailyCheckIn, batchSize int) error
	Save(values ...*model.DailyCheckIn) error
	First() (*model.DailyCheckIn, error)
	Take() (*model.DailyCheckIn, error)
	Last() (*model.DailyCheckIn, error)
	Find() ([]*model.DailyCheckIn, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DailyCheckIn, err error)
	FindInBatches(result *[]*model.DailyCheckIn, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.DailyCheckIn) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDailyCheckInDo
	Assign(attrs ...field.AssignExpr) IDailyCheckInDo
	Joins(fields ...field.RelationField) IDailyCheckInDo
	Preload(fields ...field.RelationField) IDailyCheckInDo
	FirstOrInit() (*model.DailyCheckIn, error)
	FirstOrCreate() (*model.DailyCheckIn, error)
	FindByPage(offset int, limit int) (result []*model.DailyCheckIn, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDailyCheckInDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	GetTodayCheckIn(userID int64, date string) (result *model.DailyCheckIn, err error)
	ListByUserIDAndDateRange(userID int64, fromDate string, toDate string, status string, limit int, offset int) (result []*model.DailyCheckIn, err error)
	ListPendingCheckIns() (result []*model.DailyCheckIn, err error)
	ListTimeoutCheckIns() (result []*model.DailyCheckIn, err error)
}

// GetTodayCheckIn 获取今日打卡记录
// SELECT * FROM @@table
// WHERE user_id = @userID AND check_in_date = @date::date
// LIMIT 1
func (d dailyCheckInDo) GetTodayCheckIn(userID int64, date string) (result *model.DailyCheckIn, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, userID)
	params = append(params, date)
	generateSQL.WriteString("获取今日打卡记录 SELECT * FROM daily_check_ins WHERE user_id = ? AND check_in_date = ?::date LIMIT 1 ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// ListByUserIDAndDateRange 按用户和日期范围查询打卡记录（分页）
// SELECT * FROM @@table
// WHERE user_id = @userID
//
//	AND check_in_date >= @fromDate::date
//	AND check_in_date <= @toDate::date
//	{{if status != ""}}
//	AND status = @status
//	{{end}}
//
// ORDER BY check_in_date DESC
// LIMIT @limit OFFSET @offset
func (d dailyCheckInDo) ListByUserIDAndDateRange(userID int64, fromDate string, toDate string, status string, limit int, offset int) (result []*model.DailyCheckIn, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, userID)
	params = append(params, fromDate)
	params = append(params, toDate)
	generateSQL.WriteString("按用户和日期范围查询打卡记录（分页） SELECT * FROM daily_check_ins WHERE user_id = ? AND check_in_date >= ?::date AND check_in_date <= ?::date ")
	if status != "" {
		params = append(params, status)
		generateSQL.WriteString("AND status = ? ")
	}
	params = append(params, limit)
	params = append(params, offset)
	generateSQL.WriteString("ORDER BY check_in_date DESC LIMIT ? OFFSET ? ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// ListPendingCheckIns 查询待打卡的记录（用于定时任务）
// SELECT * FROM @@table
// WHERE status = 'pending'
//
//	AND check_in_date = CURRENT_DATE
//	AND user_id IN (
//	  SELECT id FROM users WHERE daily_check_in_enabled = true AND status = 'active'
//	)
func (d dailyCheckInDo) ListPendingCheckIns() (result []*model.DailyCheckIn, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("查询待打卡的记录（用于定时任务） SELECT * FROM daily_check_ins WHERE status = 'pending' AND check_in_date = CURRENT_DATE AND user_id IN ( SELECT id FROM users WHERE daily_check_in_enabled = true AND status = 'active' ) ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String()).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// ListTimeoutCheckIns 查询超时未打卡的记录（用于定时任务）
// SELECT * FROM @@table
// WHERE status = 'pending'
//
//	AND check_in_date = CURRENT_DATE
//	AND reminder_sent_at IS NOT NULL
//	AND user_id IN (
//	  SELECT id FROM users WHERE daily_check_in_enabled = true AND status = 'active'
//	)
func (d dailyCheckInDo) ListTimeoutCheckIns() (result []*model.DailyCheckIn, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("查询超时未打卡的记录（用于定时任务） SELECT * FROM daily_check_ins WHERE status = 'pending' AND check_in_date = CURRENT_DATE AND reminder_sent_at IS NOT NULL AND user_id IN ( SELECT id FROM users WHERE daily_check_in_enabled = true AND status = 'active' ) ")

	var executeSQL *gorm.DB
	executeSQL = d.UnderlyingDB().Raw(generateSQL.String()).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (d dailyCheckInDo) Debug() IDailyCheckInDo {
	return d.withDO(d.DO.Debug())
}

func (d dailyCheckInDo) WithContext(ctx context.Context) IDailyCheckInDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dailyCheckInDo) ReadDB() IDailyCheckInDo {
	return d.Clauses(dbresolver.Read)
}

func (d dailyCheckInDo) WriteDB() IDailyCheckInDo {
	return d.Clauses(dbresolver.Write)
}

func (d dailyCheckInDo) Session(config *gorm.Session) IDailyCheckInDo {
	return d.withDO(d.DO.Session(config))
}

func (d dailyCheckInDo) Clauses(conds ...clause.Expression) IDailyCheckInDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dailyCheckInDo) Returning(value interface{}, columns ...string) IDailyCheckInDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dailyCheckInDo) Not(conds ...gen.Condition) IDailyCheckInDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dailyCheckInDo) Or(conds ...gen.Condition) IDailyCheckInDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dailyCheckInDo) Select(conds ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dailyCheckInDo) Where(conds ...gen.Condition) IDailyCheckInDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dailyCheckInDo) Order(conds ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dailyCheckInDo) Distinct(cols ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dailyCheckInDo) Omit(cols ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dailyCheckInDo) Join(table schema.Tabler, on ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dailyCheckInDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dailyCheckInDo) RightJoin(table schema.Tabler, on ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dailyCheckInDo) Group(cols ...field.Expr) IDailyCheckInDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dailyCheckInDo) Having(conds ...gen.Condition) IDailyCheckInDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dailyCheckInDo) Limit(limit int) IDailyCheckInDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dailyCheckInDo) Offset(offset int) IDailyCheckInDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dailyCheckInDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDailyCheckInDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dailyCheckInDo) Unscoped() IDailyCheckInDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dailyCheckInDo) Create(values ...*model.DailyCheckIn) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dailyCheckInDo) CreateInBatches(values []*model.DailyCheckIn, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dailyCheckInDo) Save(values ...*model.DailyCheckIn) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dailyCheckInDo) First() (*model.DailyCheckIn, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyCheckIn), nil
	}
}

func (d dailyCheckInDo) Take() (*model.DailyCheckIn, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyCheckIn), nil
	}
}

func (d dailyCheckInDo) Last() (*model.DailyCheckIn, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyCheckIn), nil
	}
}

func (d dailyCheckInDo) Find() ([]*model.DailyCheckIn, error) {
	result, err := d.DO.Find()
	return result.([]*model.DailyCheckIn), err
}

func (d dailyCheckInDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.DailyCheckIn, err error) {
	buf := make([]*model.DailyCheckIn, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dailyCheckInDo) FindInBatches(result *[]*model.DailyCheckIn, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dailyCheckInDo) Attrs(attrs ...field.AssignExpr) IDailyCheckInDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dailyCheckInDo) Assign(attrs ...field.AssignExpr) IDailyCheckInDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dailyCheckInDo) Joins(fields ...field.RelationField) IDailyCheckInDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dailyCheckInDo) Preload(fields ...field.RelationField) IDailyCheckInDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dailyCheckInDo) FirstOrInit() (*model.DailyCheckIn, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyCheckIn), nil
	}
}

func (d dailyCheckInDo) FirstOrCreate() (*model.DailyCheckIn, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.DailyCheckIn), nil
	}
}

func (d dailyCheckInDo) FindByPage(offset int, limit int) (result []*model.DailyCheckIn, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dailyCheckInDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dailyCheckInDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dailyCheckInDo) Delete(models ...*model.DailyCheckIn) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dailyCheckInDo) withDO(do gen.Dao) *dailyCheckInDo {
	d.DO = *do.(*gen.DO)
	return d
}
